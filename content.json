[{"title":"超小手势库alloyfinger及其vue版实现深入解析","date":"2017-10-11T15:00:47.000Z","path":"2017/10/11/超小手势库alloyfinger及其vue版实现深入解析/","text":"alloyfinger是一款非常轻量的开源手势库，由于其轻量、基于原生js等特性被广泛使用。关于其原理，它的官方团队解析的非常详细——传送门。相信学过高数的人看起来应该不难，这里不深入解析了。 其核心代码只有300多行，完成了14个手势，其手势并不是浏览器原生的事件，而是通过监听touchstart、touchmove、touchend、touchcancel四个原生浏览器事件hack出来的手势，故其用法与原生可能有些不同。比如阻止默认事件、阻止冒泡，不能像原生事件那样用。 官方代码除了alloyfinger的核心库外还有react、vue的实现。在这里只对核心库即vue版本的解析。 核心库： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321/* AlloyFinger v0.1.7 * By dntzhang * Github: https://github.com/AlloyTeam/AlloyFinger * Note By keenjaan * Github: https://github.com/keenjaan */; (function () &#123; // 计算距离和角度等的数学公式 // 根据两边的长度求直角三角形斜边长度(主要用于求两点距离) function getLen(v) &#123; return Math.sqrt(v.x * v.x + v.y * v.y); &#125; // 主要用于计算两次手势状态间的夹角的辅助函数 function dot(v1, v2) &#123; return v1.x * v2.x + v1.y * v2.y; &#125; // 计算两次手势状态间的夹角 function getAngle(v1, v2) &#123; var mr = getLen(v1) * getLen(v2); if (mr === 0) return 0; var r = dot(v1, v2) / mr; if (r &gt; 1) r = 1; return Math.acos(r); &#125; // 计算夹角的旋转方向，(逆时针大于0，顺时针小于0) function cross(v1, v2) &#123; return v1.x * v2.y - v2.x * v1.y; &#125; // 将角度转换为弧度，并且绝对值 function getRotateAngle(v1, v2) &#123; var angle = getAngle(v1, v2); if (cross(v1, v2) &gt; 0) &#123; angle *= -1; &#125; return angle * 180 / Math.PI; &#125; // 用于处理手势监听函数的构造函数 var HandlerAdmin = function(el) &#123; this.handlers = []; // 监听函数列表 this.el = el; // 监听元素 &#125;; // 构造函数的添加监听函数的方法 HandlerAdmin.prototype.add = function(handler) &#123; this.handlers.push(handler); &#125; // 构造函数的删除监听函数的方法 HandlerAdmin.prototype.del = function(handler) &#123; if(!handler) this.handlers = []; // handler为假值时，代表清空监听函数列表 for(var i=this.handlers.length; i&gt;=0; i--) &#123; if(this.handlers[i] === handler) &#123; this.handlers.splice(i, 1); &#125; &#125; &#125; // 触发用户事件监听回调函数 HandlerAdmin.prototype.dispatch = function() &#123; for(var i=0,len=this.handlers.length; i&lt;len; i++) &#123; var handler = this.handlers[i]; if(typeof handler === 'function') handler.apply(this.el, arguments); &#125; &#125; // 实例化处理监听函数的对象 function wrapFunc(el, handler) &#123; var handlerAdmin = new HandlerAdmin(el); handlerAdmin.add(handler); // 添加监听函数 return handlerAdmin; // 返回实例 &#125; // 手势的构造函数 var AlloyFinger = function (el, option) &#123; this.element = typeof el == 'string' ? document.querySelector(el) : el; // 绑定事件的元素 // 绑定原型上start, move, end, cancel函数的this对象为 AlloyFinger实例 this.start = this.start.bind(this); this.move = this.move.bind(this); this.end = this.end.bind(this); this.cancel = this.cancel.bind(this); // 绑定原生的 touchstart, touchmove, touchend, touchcancel事件。 this.element.addEventListener(\"touchstart\", this.start, false); this.element.addEventListener(\"touchmove\", this.move, false); this.element.addEventListener(\"touchend\", this.end, false); this.element.addEventListener(\"touchcancel\", this.cancel, false); // 保存当有两个手指以上时，两个手指间横纵坐标的差值，用于计算两点距离 this.preV = &#123; x: null, y: null &#125;; this.pinchStartLen = null; // 两个手指间的距离 this.zoom = 1; // 初始缩放比例 this.isDoubleTap = false; // 是否双击 var noop = function () &#123; &#125;; // 空函数，没有绑定事件时，传入的函数 // 对14种手势，分别实例化监听函数对象，根据option的值添加相关监听函数，没有就添加空函数。 this.rotate = wrapFunc(this.element, option.rotate || noop); this.touchStart = wrapFunc(this.element, option.touchStart || noop); this.multipointStart = wrapFunc(this.element, option.multipointStart || noop); this.multipointEnd = wrapFunc(this.element, option.multipointEnd || noop); this.pinch = wrapFunc(this.element, option.pinch || noop); this.swipe = wrapFunc(this.element, option.swipe || noop); this.tap = wrapFunc(this.element, option.tap || noop); this.doubleTap = wrapFunc(this.element, option.doubleTap || noop); this.longTap = wrapFunc(this.element, option.longTap || noop); this.singleTap = wrapFunc(this.element, option.singleTap || noop); this.pressMove = wrapFunc(this.element, option.pressMove || noop); this.touchMove = wrapFunc(this.element, option.touchMove || noop); this.touchEnd = wrapFunc(this.element, option.touchEnd || noop); this.touchCancel = wrapFunc(this.element, option.touchCancel || noop); this.delta = null; // 用于判断是否是双击的时间戳 this.last = null; // 记录时间戳的变量 this.now = null; // 记录时间戳的变量 this.tapTimeout = null; //tap事件执行的定时器 this.singleTapTimeout = null; // singleTap执行的定时器 this.longTapTimeout = null; // longTap执行的定时器 this.swipeTimeout = null; // swipe执行的定时器 this.x1 = this.x2 = this.y1 = this.y2 = null; // start时手指的坐标x1, y1, move时手指的坐标x2, y2 this.preTapPosition = &#123; x: null, y: null &#125;; // 记住start时，手指的坐标 &#125;; AlloyFinger.prototype = &#123; start: function (evt) &#123; if (!evt.touches) return; // touches手指列表，没有就return this.now = Date.now(); // 记录当前事件点 this.x1 = evt.touches[0].pageX; // 第一个手指x坐标 this.y1 = evt.touches[0].pageY; // 第一个手指y坐标 this.delta = this.now - (this.last || this.now); // 时间戳 this.touchStart.dispatch(evt); // 触发touchStart事件 if (this.preTapPosition.x !== null) &#123; // 不是第一次触摸屏幕时，比较两次触摸时间间隔，两次触摸间隔小于250ms，触摸点的距离小于30px时记为双击。 this.isDoubleTap = (this.delta &gt; 0 &amp;&amp; this.delta &lt;= 250 &amp;&amp; Math.abs(this.preTapPosition.x - this.x1) &lt; 30 &amp;&amp; Math.abs(this.preTapPosition.y - this.y1) &lt; 30); &#125; this.preTapPosition.x = this.x1; // 将此次的触摸坐标保存到preTapPosition。 this.preTapPosition.y = this.y1; this.last = this.now; // 记录本次触摸时间点 var preV = this.preV, // 获取记录的两点坐标差值 len = evt.touches.length; // 手指个数 if (len &gt; 1) &#123; // 手指个数大于1 this._cancelLongTap(); // 取消longTap定时器 this._cancelSingleTap(); // 取消singleTap定时器 var v = &#123; x: evt.touches[1].pageX - this.x1, y: evt.touches[1].pageY - this.y1 &#125;; // 计算两个手指间横纵坐标差，并保存到prev对象中，也保存到this.preV中。 preV.x = v.x; preV.y = v.y; this.pinchStartLen = getLen(preV); // 计算两个手指的间距 this.multipointStart.dispatch(evt); // 触发multipointStart事件 &#125; // 开启longTap事件定时器，如果750ms内定时器没有被清除则触发longTap事件。 this.longTapTimeout = setTimeout(function () &#123; this.longTap.dispatch(evt); &#125;.bind(this), 750); &#125;, move: function (evt) &#123; if (!evt.touches) return; var preV = this.preV, // start方法中保存的两点横纵坐标差值。 len = evt.touches.length, // 手指个数 currentX = evt.touches[0].pageX, // 第一个手指的x坐标 currentY = evt.touches[0].pageY; // 第一个手指的y坐标 this.isDoubleTap = false; // 移动了就不能是双击事件了 if (len &gt; 1) &#123; // 获取当前两点横纵坐标的差值，保存到v对象中。 var v = &#123; x: evt.touches[1].pageX - currentX, y: evt.touches[1].pageY - currentY &#125;; // start保存的preV不为空，pinchStartLen大于0 if (preV.x !== null) &#123; if (this.pinchStartLen &gt; 0) &#123; // 当前两点的距离除以start中两点距离，求出缩放比，挂载到evt对象中 evt.zoom = getLen(v) / this.pinchStartLen; this.pinch.dispatch(evt); // 触发pinch事件 &#125; evt.angle = getRotateAngle(v, preV); // 计算旋转的角度，挂载到evt对象中 this.rotate.dispatch(evt); // 触发rotate事件 &#125; preV.x = v.x; // 将move中的两个手指的横纵坐标差值赋值给preV，同时也改变了this.preV preV.y = v.y; &#125; else &#123; // 出列一根手指的pressMove手势 // 第一次触发move时，this.x2为null，move执行完会有给this.x2赋值。 if (this.x2 !== null) &#123; // 用本次的move坐标减去上一次move坐标，得到x,y方向move距离。 evt.deltaX = currentX - this.x2; evt.deltaY = currentY - this.y2; &#125; else &#123; // 第一次执行move，所以移动距离为0，将evt.deltaX,evt.deltaY赋值为0. evt.deltaX = 0; evt.deltaY = 0; &#125; // 触发pressMove事件 this.pressMove.dispatch(evt); &#125; // 触发touchMove事件，挂载不同的属性给evt对象抛给用户 this.touchMove.dispatch(evt); // 取消长按定时器，750ms内可以阻止长按事件。 this._cancelLongTap(); this.x2 = currentX; // 记录当前第一个手指坐标 this.y2 = currentY; if (len &gt; 1) &#123; evt.preventDefault(); // 两个手指以上阻止默认事件 &#125; &#125;, end: function (evt) &#123; if (!evt.changedTouches) return; // 取消长按定时器，750ms内会阻止长按事件 this._cancelLongTap(); var self = this; // 保存当前this对象。 // 如果当前留下来的手指数小于2，触发multipointEnd事件 if (evt.touches.length &lt; 2) &#123; this.multipointEnd.dispatch(evt); &#125; // this.x2或this.y2存在代表触发了move事件。 // Math.abs(this.x1 - this.x2)代表在x方向移动的距离。 // 故就是在x方向或y方向移动的距离大于30px时则触发swipe事件 if ((this.x2 &amp;&amp; Math.abs(this.x1 - this.x2) &gt; 30) || (this.y2 &amp;&amp; Math.abs(this.y1 - this.y2) &gt; 30)) &#123; // 计算swipe的方向并写入evt对象。 evt.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2); this.swipeTimeout = setTimeout(function () &#123; self.swipe.dispatch(evt); // 异步触发swipe事件 &#125;, 0) &#125; else &#123; this.tapTimeout = setTimeout(function () &#123; self.tap.dispatch(evt); // 异步触发tap事件 // trigger double tap immediately if (self.isDoubleTap) &#123; // start方法中计算的满足双击条件时 self.doubleTap.dispatch(evt); // 触发双击事件 clearTimeout(self.singleTapTimeout); // 清楚singleTap事件定时器 self.isDoubleTap = false; // 重置双击条件 &#125; &#125;, 0) if (!self.isDoubleTap) &#123; // 如果不满足双击条件 self.singleTapTimeout = setTimeout(function () &#123; self.singleTap.dispatch(evt); // 触发singleTap事件 &#125;, 250); &#125; &#125; this.touchEnd.dispatch(evt); // 触发touchEnd事件 // end结束后重置相关的变量 this.preV.x = 0; this.preV.y = 0; this.zoom = 1; this.pinchStartLen = null; this.x1 = this.x2 = this.y1 = this.y2 = null; &#125;, cancel: function (evt) &#123; // 关闭所有定时器 clearTimeout(this.singleTapTimeout); clearTimeout(this.tapTimeout); clearTimeout(this.longTapTimeout); clearTimeout(this.swipeTimeout); this.touchCancel.dispatch(evt); &#125;, _cancelLongTap: function () &#123; clearTimeout(this.longTapTimeout); // 关闭longTap定时器 &#125;, _cancelSingleTap: function () &#123; clearTimeout(this.singleTapTimeout); // 关闭singleTap定时器 &#125;, _swipeDirection: function (x1, x2, y1, y2) &#123; // 判断swipe方向 return Math.abs(x1 - x2) &gt;= Math.abs(y1 - y2) ? (x1 - x2 &gt; 0 ? 'Left' : 'Right') : (y1 - y2 &gt; 0 ? 'Up' : 'Down') &#125;, // 给14中手势中一种手势添加监听函数 on: function(evt, handler) &#123; if(this[evt]) &#123; // 事件名在这14中之中，才添加函数到监听事件中 this[evt].add(handler); &#125; &#125;, // 给14中手势中一种手势移除监听函数 off: function(evt, handler) &#123; if(this[evt]) &#123; // 事件名在这14中之中，才移除相应监听函数 this[evt].del(handler); &#125; &#125;, // 清空，重置所有数据 destroy: function() &#123; // 关闭所有定时器 if(this.singleTapTimeout) clearTimeout(this.singleTapTimeout); if(this.tapTimeout) clearTimeout(this.tapTimeout); if(this.longTapTimeout) clearTimeout(this.longTapTimeout); if(this.swipeTimeout) clearTimeout(this.swipeTimeout); // 移除touch的四个事件 this.element.removeEventListener(\"touchstart\", this.start); this.element.removeEventListener(\"touchmove\", this.move); this.element.removeEventListener(\"touchend\", this.end); this.element.removeEventListener(\"touchcancel\", this.cancel); // 清除所有手势的监听函数 this.rotate.del(); this.touchStart.del(); this.multipointStart.del(); this.multipointEnd.del(); this.pinch.del(); this.swipe.del(); this.tap.del(); this.doubleTap.del(); this.longTap.del(); this.singleTap.del(); this.pressMove.del(); this.touchMove.del(); this.touchEnd.del(); this.touchCancel.del(); // 重置所有变量 this.preV = this.pinchStartLen = this.zoom = this.isDoubleTap = this.delta = this.last = this.now = this.tapTimeout = this.singleTapTimeout = this.longTapTimeout = this.swipeTimeout = this.x1 = this.x2 = this.y1 = this.y2 = this.preTapPosition = this.rotate = this.touchStart = this.multipointStart = this.multipointEnd = this.pinch = this.swipe = this.tap = this.doubleTap = this.singleTap = this.pressMove = this.touchMove = this.touchEnd = this.touchCancel = null; return null; &#125; &#125;; // 如果当前环境支持module，exports等es6语法，则导出AlloyFingerPlugin模块 if (typeof module !== 'undefined' &amp;&amp; typeof exports === 'object') &#123; module.exports = AlloyFinger; &#125; else &#123; // 否则将AlloyFingerPlugin注册到全局对象 window.AlloyFinger = AlloyFinger; &#125;&#125;)(); vue 版本代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/* AlloyFinger v0.1.0 for Vue * By june01 * Github: https://github.com/AlloyTeam/AlloyFinger * Note By keenjaan * Github: https://github.com/keenjaan */; (function() &#123; var AlloyFingerPlugin = &#123; // 用于vue挂载指令的install函数 install: function(Vue, options) &#123; // options挂载指令时传递的参数 options = options || &#123;&#125;; // AlloyFinger全局中获取，没有就读取options中获取。 var AlloyFinger = window.AlloyFinger || options.AlloyFinger; // 判断vue的版本 var isVue2 = !!(Vue.version.substr(0,1) == 2); // 获取不到AlloyFinger抛出异常 if(!AlloyFinger) &#123; throw new Error('you need include the AlloyFinger!'); &#125; // 14中手势命名 var EVENTMAP = &#123; 'touch-start': 'touchStart', 'touch-move': 'touchMove', 'touch-end': 'touchEnd', 'touch-cancel': 'touchCancel', 'multipoint-start': 'multipointStart', 'multipoint-end': 'multipointEnd', 'tap': 'tap', 'double-tap': 'doubleTap', 'long-tap': 'longTap', 'single-tap': 'singleTap', 'rotate': 'rotate', 'pinch': 'pinch', 'press-move': 'pressMove', 'swipe': 'swipe' &#125;; // 记录元素添加监听事件的数组。 var CACHE = []; // 创建空对象，用于存放vue自定义指令directive的参数对象 var directiveOpts = &#123;&#125;; // 获取某个元素在CACHE中是否存在，存在返回index，不存在返回null var getElemCacheIndex = function(elem) &#123; for(var i=0,len=CACHE.length; i&lt;len; i++) &#123; if(CACHE[i].elem === elem) &#123; return i; &#125; &#125; return null; &#125;; // 绑定或解绑事件监听函数 var doOnOrOff = function(cacheObj, options) &#123; var eventName = options.eventName; // 事件名 var elem = options.elem; // 监听元素 var func = options.func; // 监听函数 var oldFunc = options.oldFunc; // dom更新时，旧的监听函数 // 如果给该元素添加过事件 if(cacheObj &amp;&amp; cacheObj.alloyFinger) &#123; // 如果是dom更新触发的，不是初始化绑定事件，即oldFunc存在，就解绑上一次绑定的函数oldFunc。 if(cacheObj.alloyFinger.off &amp;&amp; oldFunc) cacheObj.alloyFinger.off(eventName, oldFunc); // 如果func存在，不管是初始化还是dom更新，都绑定func if(cacheObj.alloyFinger.on &amp;&amp; func) cacheObj.alloyFinger.on(eventName, func); &#125; else &#123; // 如果没有给该元素添加过事件 options = &#123;&#125;; // 创建空对象 options[eventName] = func; // 添加监听事件的监听函数 // 向CACHE中添加监听元素及其监听的事件和函数 CACHE.push(&#123; elem: elem, alloyFinger: new AlloyFinger(elem, options) // 初始化AlloyFinger绑定相关事件 &#125;); &#125; &#125;; // vue 自定义指令的初始化函数 var doBindEvent = function(elem, binding) &#123; var func = binding.value; // 监听函数 var oldFunc = binding.oldValue; // 旧的监听函数 var eventName = binding.arg; // 监听的事件名 eventName = EVENTMAP[eventName]; // 将事件名转换为驼峰法 var cacheObj = CACHE[getElemCacheIndex(elem)]; // 获取某个元素是否添加过事件监听，添加到CACHE。 // 触发事件监听函数的绑定或移除 doOnOrOff(cacheObj, &#123; elem: elem, func: func, oldFunc: oldFunc, eventName: eventName &#125;); &#125;; // 移除事件监听函数 var doUnbindEvent = function(elem) &#123; var index = getElemCacheIndex(elem); // 在CACHE中获取elem的index值 if(!isNaN(index)) &#123; // 如果元素在CACHE中存在 var delArr = CACHE.splice(index, 1); // 删除该条监听事件 if(delArr.length &amp;&amp; delArr[0] &amp;&amp; delArr[0].alloyFinger.destroy) &#123; delArr[0].alloyFinger.destroy(); // 重置手势alloyFinger对象，停止所有定时器，移除所有监听函数，清空所有变量。 &#125; &#125; &#125;; // 判断vue版本 if(isVue2) &#123; // vue2 // directive参数 directiveOpts = &#123; bind: doBindEvent, update: doBindEvent, unbind: doUnbindEvent &#125;; &#125; else &#123; // vue1 // vue1.xx directiveOpts = &#123; update: function(newValue, oldValue) &#123; var binding = &#123; value: newValue, oldValue: oldValue, arg: this.arg &#125;; var elem = this.el; doBindEvent.call(this, elem, binding); &#125;, unbind: function() &#123; var elem = this.el; doUnbindEvent.call(this, elem); &#125; &#125; &#125; // definition Vue.directive('finger', directiveOpts); // 绑定自定义指令finger &#125; &#125; // 如果当前环境支持module，exports等es6语法，则导出AlloyFingerPlugin模块 if(typeof module !== 'undefined' &amp;&amp; typeof exports === 'object') &#123; module.exports = AlloyFingerPlugin; &#125; else &#123; // 否则将AlloyFingerPlugin注册到全局对象 window.AlloyFingerVue = AlloyFingerPlugin; &#125;&#125;)(); 上面是整个代码解析，其中有几个问题点： 1、长按是否需要取消tap、swipe、touchend、singleTap、doubleTap等end里面的所有事件。 如果要取消end里的所有事件，就要添加一个字段isLongTap, 在触发longTap事件时设置为true。在end里判断isLongTap的值，如果为true则return掉，阻止end里的所有事件，并将isLongTap重置为false 2、swipe事件和doubleTap的界定，源码中对swipe与tap的区别是move的距离，当move的距离在x、y方向上都小于等于30px时就为tap事件，大于30px时就为swipe事件。doubleTap也一样，两次点击的距离在x、y方向上都小于等于30px，其界定的30px是设置了如下代码： 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"&gt; 即设置页面宽度为设备的理想视口。在我的实际项目中如果进行如上设置，30px这个值可能有点大，会导致想触发swipe事件结果变成了tap事件。至于到底多少，你们可以试一下效果，找到符合你们团队的分界值。 还有就是在实际的移动项目中，我们可能并不会这样设置你的视口，比如淘宝团队的flexible适配。其ios端对页面视口进行了缩放，android端都是用的理想视口(没有缩放视口)，这样就造成30px对应到屏幕的滑动距离不同。在ios端滑动距离较小就能触发swipe事件。这种情况下就不能直接使用，要结合你的移动端适配库，要对alloyfinger源码做调整。关于移动端适配可以查看我的这篇文章 传送门 方法一：在alloyfinger源码中直接读取viewport的缩放，对于不同适配机型设置不同的修正值，使得在所有机型上触发swipe事件，手指移动的距离相同。 方法二：是对于vue版本的实现，通过vue的自定义指令，在挂在指令时，动态的通过参数传进去。 1Vue.use(AlloyFingerVue, option) // 通过参数传进去。 在AlloyFingerPlugin的install函数中获取option对象，再将option对象注入到alloyfinger对象中，在alloyfinger中再对swipe的分界值进行修正。具体实现方案我源码中已实现，注释写的很清楚，不懂可以问我，源码链接见文章结尾。 3、阻止冒泡，因为其事件除了touchstart、touchmove、touchend、touchcancel四个原生事件外，其它都是hack的，所以并不能像原生事件那样在监听函数中写阻止冒泡。需要在相应的原生事件中阻止冒泡。在vue版本中可以通过注册指令时，传入参数来阻止冒泡。如： 1v-finger:tap.stoppropagation 在doOnOrOff函数中可以通过modifiers字段读取到stoppropagation字段，再将stoppropagation字段注册到alloyfinger对象中。在alloyfinger对象对去该字段来判断是否需要阻止冒泡。 优点: 阻止冒泡非常方便，在绑定事件时加一个修饰符即可。 缺点：一旦阻止了冒泡，该元素上所有的事件都阻止了冒泡，如果某一事件需要冒泡，还需特殊处理。 针对以上三点，在官方版本进行了修改。源码请见 传送门","tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"手势库","slug":"手势库","permalink":"http://yoursite.com/tags/手势库/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"移动端页面适配———多方案解析","date":"2017-09-26T15:00:47.000Z","path":"2017/09/26/移动端页面适配———多方案解析/","text":"在移动互联网快速发展的今天，手机的种类和尺寸越来越多，作为前端的小伙伴们可能会越来越头疼，但又不得不去适配一款又一款的新机型。对于移动端适配，不同的公司、不同的团队有不同的解决方案。我在项目中也用了一部分解决方案，也看到了一些解决方案，对比下，总结一些自己的理解，希望对各位有帮助，找到最适合你们项目的适配方案。 下面是一些基础概念的讲解，帮助理解各种适配方案实现。###像素： 1、物理像素（设备像素）屏幕的物理像素，又被称为设备像素，他是显示设备中一个最微小的物理部件。任何设备屏幕的物理像素出厂时就确定了，且固定不变的。 2、设备独立像素设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。 3、设备像素比设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系 123设备像素比 ＝ 物理像素 / 设备独立像素以iphone6为例：iphone6的设备宽和高为375pt * 667pt，可以理解为设备的独立像素，而其设备像素比为2.固有设备像素为750pt * 1334pt 通过：window.devicePixelRatio获得。 设备像素比是区别是否是高清屏的标准，dpr大于1时就为高清屏，一般情况下dpr为整数，但是android有些奇葩机型不为整数。 4、css像素在CSS、JS中使用的一个长度单位。单位px 注：在pc端1物理像素等于1px，但是移动端1物理像素不一定等于1px，1物理像素与px的关系与以下因素有关。(有些视口概念，可以把下面视口看完了再来看) 121、屏幕布局视口大小(下面会讲到)2、屏幕的分辨率(物理像素) 对于一块屏幕，其物理像素是确定的。视觉视口尺寸是继承的布局视口的，而视觉视口里宽度即是css的px数。故在一块屏上物理像素与px的关系就是物理像素与布局视口的px数的关系。 1234567比如iphone6，期物理像素为750，如果没有设置布局视口时，viewport为980px此时：1物理像素长度等于980/750px = 1.3067px的长度由于像素都是点阵的，故1物理像素相当于1.3067px * 1.3067px方格。当在meta中设置了如下配置时&lt;meta name=\"viewport\" content=\"width=device-width\"&gt;相当于把布局视口设置为设备的宽度(即上面讲到的设备独立像素)， 对于iphone6就是375px。此时1物理像素长度等于375/750px = 0.5px的长度，故1物理像素相当于0.5px * 0.5px的方格。 视口：1、布局视口：在html中一般在meta中的name为viewport字段就是控制的布局视口。布局视口一般都是浏览器厂商给的一个值。在手机互联网没有普及前，网络上绝大部分页面都是为电脑端浏览而做的，根本没有做移动端的适配。随着移动端的发展，在手机上看电脑端的页面已成为非常普及现象。而电脑端页面宽度较大，移动端宽度有限，要想看到整个网页，会有很长的滚动条，看起来非常麻烦。于是浏览器厂商为了让用户在小屏幕下网页也能够显示地很好，所以把布局视口设置的很大，一般在768px ~ 1024px 之间，最常用的宽度就是 980。这样用户就能看到绝大部分内容，并根据具体内容选择缩放。 故布局视口是看不见的，浏览器厂商设置的一个固定值，如980px，并将980px的内容缩放到手机屏内。 布局视口可以通过： 1document.documentElement.clientWidth(clientHeight) // 布局视口的尺寸。 2、视觉视口：浏览器可视区域的大小，即用户看到的网页的区域。(其宽度继承的布局视口宽度) 1window.innerWidth(innerHeight) // 视觉视口尺寸 3、理想视口:布局视口虽然解决了移动端查看pc端网页的问题，但是完全忽略了手机本身的尺寸。所以苹果引入了理想视口，它对设备来说是最理想的布局视口，用户不需要对页面进行缩放就能完美的显示整个页面。最简单的做法就是使布局视口宽度改成屏幕的宽度。 可以通过window.screen.width获取。 1&lt;meta name=\"viewport\" content=\"width=device-width\"&gt; 移动端到底怎么适配不同的屏幕呢？最简单的方法是设置如下视口： 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"&gt; 当使用以上方案定义布局视口时，即布局视口等于理想视口（屏幕宽度），屏幕没有滚动条，不存在高清屏下，字体较小的问题。但是在不同屏幕上，其视觉宽度是不同的，不能简单的将所有的尺寸都设置为px，可能会出现滚动条。小尺寸的可以用px，大尺寸的只能用百分比和弹性布局。 viewport缩放对于上面的设置，再不同的屏幕上，css像素对应的物理像素具数是不一致的。 在普通屏幕下，dpr=1时， 1个css像素长度对应1个物理像素长度，1个css像素对应1个物理像素。 而在Retina屏幕下，如果dpr=2， 1个css像素长度对应2个物理像素长度，1css像素对应4个物理像素。 此时如果css中写 1border: 1px solid red; // 此时1px 对应的宽度是2物理像素的宽度。 而一般现在移动端设计稿都是基于iphone设计的，稿子一般为750px或640px，这正好是iphone6和iphone5的物理像素。在设计稿中，一般有些边框效果，这时边框的线宽为1px，对应的就是1物理像素。而对于iphone5和iphone6，当width=device-width时，css的1px显示出来的是2个物理像素，所以看起来线就比较粗。怎么解决呢？1px边框效果其实有很多hack方法，其中一种就是通过缩放viewport。 initial-scale是将布局视口进行缩放，initial-scale是相对于理想视口的，即initial-scale=1与width=device-width是一样的效果。initial-scale=0.5等效于width= 2倍的device-width，所以设置initial-scale和width都可以改变布局视口的大小。 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no\"&gt; 对于iphone6当添加如上设置后，initial-scale=0.5,即将页面缩小2倍后等于屏幕宽度。 12布局视口width:width / 2 = 375px; width = 750px; 所以此时布局视口为750px，此时1px等于1物理像素。 适配方案：上面讲了一些基础概念，下面讲具体适配。 对于ui设计师给的一张设计稿，怎么将其还原到页面上？对于不同手机屏幕，其dpr不同，屏幕尺寸也不同，考虑到各种情况，有很多适配方案，所以不同的适配方案，实现方法不同，处理复杂度也不同，还原程度也不同。 方案一： 固定高度，宽度自适应。 这种方案是目前使用较多的方案，也是相对较简单的实现方案： 该方法使用了理想视口： 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"&gt; 垂直方向使用固定的值，水平方向使用弹性布局，元素采用定值、百分比、flex布局等。这种方案相对简单，还原度也非常低。 方案二： 固定布局视口宽度，使用viewport进行缩放 如：荔枝FM、网易应用 荔枝的代码： 123456789101112131415161718if(/Android (\\d+\\.\\d+)/.test(navigator.userAgent))&#123; var version = parseFloat(RegExp.$1); if(version&gt;2.3)&#123; var phoneScale = parseInt(window.screen.width)/640; if(/MZ-M571C/.test(navigator.userAgent))&#123; document.write('&lt;meta name=\"viewport\" content=\"width=640, minimum-scale = 0.5, maximum-scale= 0.5\"&gt;'); &#125;else if(/M571C/.test(navigator.userAgent)&amp;&amp;/LizhiFM/.test(navigator.userAgent))&#123; document.write('&lt;meta name=\"viewport\" content=\"width=640, minimum-scale = 0.5, maximum-scale= 0.5\"&gt;'); &#125;else&#123; document.write('&lt;meta name=\"viewport\" content=\"width=640, minimum-scale = '+ phoneScale +', maximum-scale = '+ phoneScale +', target-densitydpi=device-dpi\"&gt;'); &#125; &#125;else&#123; document.write('&lt;meta name=\"viewport\" content=\"width=640, target-densitydpi=device-dpi\"&gt;'); &#125;&#125;else&#123; document.write('&lt;meta name=\"viewport\" content=\"width=640, user-scalable=no, target-densitydpi=device-dpi\"&gt;');&#125; 固定布局视口，宽度设置固定的值，总宽度为640px，根据屏幕宽度动态生成viewport。（设计稿应该是640px的） 1&lt;meta name=\"viewport\" content=\"width=640, minimum-scale = 0.5625, maximum-scale = 0.5625, target-densitydpi=device-dpi\"&gt; 这种方式布局如荔枝FM的网页宽度始终为640px。缩放比例scale为： 1var scale = window.screen.width / 640 设计稿为640px时，正好可以1:1以px来写样式。但是1px所对应的物理像素就不一定是1了。 1(window.screen.width * dpr) / 640 // 1px对应的物理像素 方案三： 根据不同屏幕动态写入font-size，以rem作为宽度单位，固定布局视口。 如网易新闻： 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"&gt; 以640px设计稿和750px的视觉稿，网易这样处理的： 123var width = document.documentElement.clientWidth; // 屏幕的布局视口宽度var rem = width / 7.5; // 750px设计稿将布局视口分为7.5份var rem = width / 6.4; // 640px设计稿将布局视口分为6.4份 这样不管是750px设计稿还是640px设计稿，1rem 等于设计稿上的100px。故px转换rem时： 1rem = px * 0.01; 在750px设计稿上： 123456789101175px 对应 0.75rem, 距离占设计稿的10%；在ipone6上：width = document.documentElement.clientWidth = 375px；rem = 375px / 7.5 = 50px;0.75rem = 37.5px; (37.5/375=10%；占屏幕10%) 在ipone5上：width = document.documentElement.clientWidth = 320px；rem = 320px / 7.5 = 42.667px;0.75rem = 32px; (32/320=10%；占屏幕10%) 故对于设计稿上任何一个尺寸换成rem后，在任何屏下对应的尺寸占屏幕宽度的百分比相同。故这种布局可以百分比还原设计图。 方案四： 以rem作为宽度单位，动态写入viewport和font-size进行缩放。 根据设置的dpr设置font-size。如： 12document.documentElement.style.fontSize = 50 * dpr;// dpr 为设置的设备像素比。（注意不是设备自身的设备像素比，而是认为设置的dpr） 这种情况下，dpr = 1时，1rem = 50px; dpr = 2时， 1rem = 100px; 当设计以iphone6为标准，出750px的设计稿时，此时dpr=2，故1rem 等于100px，将图上的尺寸转换为rem非常方便，除以100就行。代码如下： 1234567891011121314151617var scale = 1.0;var dpr = 1;var isAndroid = window.navigator.appVersion.match(/android/gi);var isIPhone = window.navigator.appVersion.match(/iphone/gi);var devicePixelRatio = window.devicePixelRatio;// 此处只简单对ios做了伸缩处理，安卓没有做伸缩处理，统一dpr = 1if ( isIPhone ) &#123; scale /= devicePixelRatio; dpr *= devicePixelRatio;&#125;var viewport = document.getElementById('viewport');var content = 'initial-scale=' + scale + ', maximum-scale=' + scale + ',minimum-scale=' + scale + ', width=device-width, user-scalable=no';viewport.setAttribute( 'content', content );document.documentElement.style.fontSize = 50 * dpr + 'px';document.documentElement.setAttribute('data-dpr', dpr); 对于该方案， 12345678910假设肉眼看到的宽度（视觉宽度）：visualWidth,令dpr=1时，其1rem对应的宽度为50.dpr = 1 时， 1rem = 50px, initial-scale=1, 缩放为1。visualWidth = 50 * 1 = 50;dpr = 2 时， 1rem = 100px, initial-scale=0.5, 缩放为0.5。visualWidth = 100 * 0.5 = 50;dpr = 3 时， 1rem = 150px, initial-scale=0.3333, 缩放为0.3333。visualWidth = 150 * 0.3333 = 50; 所以该方案，1rem在所有屏幕上对应的肉眼距离相同，故不同屏幕下，总的rem数不同，大屏下总的rem数大于小屏下，如iphone6下，总宽度为7.5rem，iphone5下，总宽度为6.4rem。故此方案不能百分比还原设计稿，故写样式时，对于大块元素应该用百分比，flex等布局，不能直接用rem。 关于这个方案的详细教程请参考这篇文章传送门 方案五： 根据不同屏幕动态写入font-size和viewport，以rem作为宽度单位 将屏幕分为固定的块数10： 12var width = document.documentElement.clientWidth; // 屏幕的布局视口宽度var rem = width / 10; // 将布局视口分为10份 这样在任何屏幕下，总长度都为10rem。1rem对应的值也不固定，与屏幕的布局视口宽度有关。 对于动态生成viewport，他们原理差不多，根据dpr来设置缩放。看看淘宝的： 123456789101112131415var devicePixelRatio = window.devicePixelRatio;var isIPhone = window.navigator.appVersion.match(/iphone/gi);var dpr,scale;if (isIPhone) &#123; if (devicePixelRatio &gt;=3) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;=2) &#123; dpr = 2; &#125; else &#123; dpr = 1; &#125;&#125; else &#123; dpr = 1;&#125;scale = 1 / dpr; 淘宝只对iphone做了缩放处理，对于android所有dpr=1，scale=1即没有缩放处理。 此方案与方案三相似，只是做了viewport缩放，能百分比还原设计稿。 适配中要解决的问题 ： 移动端适配最主要的是使在不同屏幕下不用缩放页面就能正常显示整个页面。以上方案都完成了这一需求。其次有几个需求： 1、解决高清屏下1px的问题，其实有很多hack方法，这里只讲了缩放视口。先将布局视口设置为高清屏的物理像素。这样css中1px就是1个物理像素，这样看到的线条才是真正的1px。但是此时视口宽度大于设备的宽度，就会出现滚动条。故对视口进行缩放，使视口宽度缩放到设备宽度。 淘宝团队在处理安卓端的缩放存在很多问题，所以dpr都做1处理，所以安卓端就没有解决1px的问题。 2、在大屏手机中一行看到的段落文字应该比小屏手机的多。 由于淘宝和网易新闻rem都是百分比，故如果用rem一行显示的文字个数应该是相同的。故对于段落文本不能用rem作为单位，应该用px处理，对于不同的dpr下设置不同的字体。 123456789101112.selector &#123; color: red; font-size: 14px; &#125;[data-dpr=\"2\"] .selector &#123; font-size: 28px; // 14 * 2&#125; [data-dpr=\"3\"] .selector &#123; font-size: 42px; // 14 * 3&#125; 对于方案四，不管什么情况下，1rem对应的视觉上的宽度都是一样的，而对应的大屏、小屏手机其视觉宽度当然不同，故字体设置为rem单位时，也能满足大屏手机一行显示的字体较多这个需求。 五种方案对比： 上面四种方案对设计稿还原程度是有差别的。 除了方案一和方案四以外，其他方案都是百分比还原设计稿，大屏下元素的尺寸就大。 方案一还原设计稿程度较低，这里不做说明。 方案二做了百分比适配，部分1px适配，没有字体适配。 方案三做了百分比适配，没有1px适配，有字体大小适配。 方案四没有做百分百适配，布局要用百分百和flex布局，做了1px的适配，并且对于段落文字直接可以用rem做单位，不需要做适配。 方案五做了百分比适配，有1px适配，有字体大小适配。 项目中遇到的问题： 在我们项目中方案四和方案五都用过。 方案五在使用中没有遇到什么问题，就是刚开始没有做字体适配都是用的rem，后面加入了字体适配，这种方案设计师相对轻松些，不用考虑在大小屏幕下的布局效果。 方案四时没有跟ui设计师沟通清楚，导致设计师在设计图上一行排了很多交互元素，在小屏下放不下去，又不能简单放百分比（元素里的文字放不下）。所以还是要做动态判断大小屏，做出相应适配。这个方案可能设计师需要考虑的多些，尽量减少一行内的交互元素，当一行交互元素多时要考虑小屏手机怎么适配。 其实对于1px的适配在苹果端很好，在android端各个厂商手机差别太大，适配有很多问题。这是为什么绝大多数方案里都放弃了android端1px适配。不过最近看到很多网站都用了densitydpi=device-dpi这个安卓的私有属性来兼容部分安卓机型，这个属性在新的webkit已经被移除了，使用它主要为了兼容低版本的android系统。 这里大漠老师针对flexible方案进行了改版，兼容了更多的android机型的1px效果。文章传送门 他给了个压缩版的方案，我看了下源码，把它写了一遍，不知道有没有问题，效果是一样的。 1234567891011121314151617181920212223242526272829303132333435363738394041var dpr, scale, timer, rem;var style = document.createElement('style');dpr = window.devicePixelRatio || 1;scale = 1 / dpr;document.documentElement.setAttribute('data-dpr', dpr);var metaEl = document.createElement('meta');metaEl.setAttribute('name', 'viewport');metaEl.setAttribute('content', 'target-densitydpi=device-dpi, initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');document.documentElement.firstElementChild.appendChild(metaEl);document.documentElement.firstElementChild.appendChild(style);if (980 === document.documentElement.clientWidth) &#123; metaEl.setAttribute('content', 'target-densitydpi=device-dpi,width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1');&#125;function refreshRem () &#123; var c = '&#125;'; var width = document.documentElement.clientWidth; var isPhone = window.navigator.userAgent.match(/Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i); if (!isPhone &amp;&amp; width &gt; 1024) &#123; width = 640; c = 'max-width:' + width + 'px;margin-right:auto!important;margin-left:auto!important;&#125;'; &#125; window.rem = rem = width / 16; style.innerHTML = 'html&#123;font-size:' + rem + 'px!important;&#125;body&#123;font-size:' + parseInt(12 * (width / 320)) + 'px;' + c;;&#125;refreshRem();window.addEventListener('resize', function () &#123; clearTimeout(timer); timer = setTimeout(refreshRem, 300);&#125;, false);window.addEventListener('pageshow', function (e) &#123; if (e.persisted) &#123; clearTimeout(timer); timer = setTimeout(refreshRem, 300); &#125;&#125;, false); 这些方案只是针对绝大部分机型，项目中可能有些特殊机型有特殊问题，需要特殊对待。比如在这篇文章中作者使用flexible在小米max和荣耀8中有问题，需要特殊hack。传送门，我没有这种手机，也没有对此做验证。 对于上面的五种方案，方案五看似是适配最好的，但是当项目中引入第三方插件时可能要一一适配，比如：引入一个富文本，里面设置字体大小的一般都是px，你需要将其一一转换成rem。而对于方案二，可以直接用px做单位来百分百还原设计稿，引入的插件时也不用适配。所以说，具体项目中用哪个方案，其实不光是前端的选择，还要跟设计师讨论下，满足设计需求，选择最适合项目的方案。 以上是个人对于移动端适配的一些理解，如有不对欢迎指正。 参考文章： 移动前端开发之viewport的深入理解 再谈Retina下1px的解决方案 使用Flexible实现手淘H5页面的终端适配 移动端适配方案(上) viewports剖析","tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"适配","slug":"适配","permalink":"http://yoursite.com/tags/适配/"}]},{"title":"提升npm下载速度之npm换源","date":"2017-08-16T15:00:47.000Z","path":"2017/08/16/提升npm下载速度之npm换源/","text":"说到换源先说下什么是换源，为什么要换源。 一般对于一个软件有很多不同资源，不同的资源下载的速度有很大差异，就像在迅雷上下载资源一样，有的资源下载速度可以达到10M/s，而有的则只有10K/s，并且到后面根本下载不了。 软件也一样，有很多不同的资源，下载的速度自然有差异。npm相当于一个软件商店，只是上面的软件都是免费。上面的软件当然有不同的资源，下载速度当然有很大差异。npm默认下载地址是国外的，下载速度当然慢。所以npm换源是将npm的资源换成国内的资源地址。 看到这里可能有人说这还不简单，直接全局安装个cnpm模块， 1npm install -g cnpm 所有包都用cnpm来安装一路畅通，没错cnpm模块很好用，安装也很快，有很长一段时间我也是用的cnpm，直到有一次安装出现了问题。在绝大多数情况下cnpm是没有问题的，但是以下情况有问题： 1、有些npm包中集成了npm install ，最后都会调用npm install ，这种情况下，cnpm完全无效。 2、有些npm API 相关的package，都会读取.npmrc中的registry,或者使用默认的registry去查询npm package相关信息。 故解决这些问题的根本方法是给npm换源。 国内有一些优秀的npm镜像，比如淘宝镜像，cnpm等。 淘宝npm镜像搜索地址：http://npm.taobao.org/ cnpmjs镜像搜索地址：http://cnpmjs.org/ 我们只需要将资源地址改为国内镜像就可以。如下： 1、通过 config 配置指向国内镜像源 12npm config set registry http://registry.cnpmjs.org // 配置源的指向npm install express // 安装express 2、通过 npm 命令指定下载源 1npm --registry http://registry.cnpmjs.org install express // 配置源并安装express模块 3、在配置文件 .npmrc 文件写入源地址 12打开电脑的个人用户目录下的.npmrc文件，没有就新建。registry=http://registry.cnpmjs.org // 写入这段 前两种方法是临时的改变源，第三种是永久改变源。 对于换源推荐一个npm模块nrm。nrm是一个npm源管理工具，其切换源非常方便。 12345npm install -g nrm // 全局安装nrm模块nrm ls // 显示所有可用的源nrm use taobao // 切换到淘宝源： 特殊： 有些模块即使换了源还是安装非常慢以至于安装失败，比如：node-sass。 在安装node-sass过程中，是要在 GitHub 上下载编译好的 node-sass 二进制包，本来github访问速度就慢，request访问速度更慢。 故需要特殊配置： 在.npmrc文件中加入： 1sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ 在npm安装有些包时会遇到一些问题，你只需google一下，找到相关配置写到.npmrc文件中。 参考文章： 是时候放弃用 cnpm 命令了 安装 nrm 自由切换 npm 源 国内镜像提升下载速度","tags":[{"name":"npm换源","slug":"npm换源","permalink":"http://yoursite.com/tags/npm换源/"},{"name":"nrm","slug":"nrm","permalink":"http://yoursite.com/tags/nrm/"}]},{"title":"阿里云centos部署git服务","date":"2017-08-04T16:35:55.000Z","path":"2017/08/05/阿里云centos部署git服务/","text":"安装git1yum install -y git 我选择/data/git/demo.git作为仓库 12345mkdir -p /data/git // 新建文件夹cd /data/git // 进入/data/git文件夹git init --bare demo.git // 创建一个裸仓库 关于–bare参数及其作用详情请看这篇文章传送门 创建git用户 1adduser git 将learngit.git拥有者给到git用户 1chown git:git demo.git 在本地拉取demo仓库 1git clone git@阿里云外网地址:/data/git/demo.git 第一，当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： 123The authenticity of host &apos;xx.xx.xx.xx&apos; can&apos;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 输入yes，后又要输入密码，输入密码，仓库成功拉取到了本地。但是一般都是用代替密码来验证的。 生成SSH Key密钥在用户主目录下，看看有没有.ssh目录，.ssh里有没有id_rsa和id_rsa.pub两个文件。有代表你以前生成过密钥，不用重新生成。(我的之前生成的公钥一直要密码登录，但是重新生成后就没有问题了) 1ssh-keygen -t rsa -C &quot;email@example.com&quot; // 生成密钥 tips: 关于git的详细教程，不懂的可以移步廖雪峰老师的网站学习传送门 服务器配置git公钥验证 12345vi /etc/ssh/sshd_config // 编辑配置文件RSAAuthentication yes // 去掉注释 # PubkeyAuthentication yes // 去掉注释 #AuthorizedKeysFile .ssh/authorized_keys // .ssh/authorized_keys 为公钥配置文件 .ssh/authorized_keys 在 /home/git文件下，故要新建文件 12mkdir -p /home/git/.ssh // 新建文件夹touch authorized_keys // 新建文件 复制本地git生成的id_rsa.pub文件中内容，粘贴到authorized_keys中，保存。 1git clone git@阿里云外网地址:/data/git/demo.git 发现不要密码也可以拉取仓库了。 禁用git用户的shell登陆处于安全考虑，git用户不能通过shell登录。 123git:x:1002:1002:,,,:/home/git:/bin/bash // 将这句改成下面这句git:x:1002:1002:,,,:/home/git:/usr/bin/git-shell 到此，git的配置就完成了。","tags":[{"name":"阿里云","slug":"阿里云","permalink":"http://yoursite.com/tags/阿里云/"},{"name":"centos","slug":"centos","permalink":"http://yoursite.com/tags/centos/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"阿里云cento下部署node和nginx","date":"2017-08-04T14:32:52.000Z","path":"2017/08/04/阿里云cento下部署node和nginx/","text":"### node 安装 参考阿里云node安装教程,使用wget下载免安装的、已编译好的二进制文件，解压后，bin文件夹中存在node 和 npm。 1、wget下载node.js安装包。 12wget https://nodejs.org/dist/v6.9.5/node-v6.9.5-linux-x64.tar.xz // 安装node6.9.5版本，如果其他版本可以自己换 2、 解压文件。 1tar xvf node-v6.9.5-linux-x64.tar.xz 3、移动文件到 /usr/local/node文件里 123mkdir -p /usr/local/node // 新建文件夹mv /root/node-v6.9.5-linux-x64/* /usr/local/node/ // 将文件移动到/usr/local/node下。 4、到此node和npm只能在 /usr/local/node/bin文件下使用，要想node和npm全局有效，可以通过创建软连接。 123456ln -s /usr/local/node/bin/node /usr/local/bin/node // 创建node软连接ln -s /usr/local/node/bin/npm /usr/local/bin/npm // 创建npm软连接如果文件想换个目录，可以先删除软连接，在创建软连接：rm -f /usr/local/bin/noderm -f /usr/local/bin/npm 5、查看node和npm版本 12node -vnpm -v 到此整个node就安装完了，node的安装方法有很多，另一种常见的是编译安装，编译安装相对较复杂些，网上教程很多，这里不展开来讲了。 新建app.js，编辑相关代码： 1234567891011const http = require(&apos;http&apos;);const hostname = &apos;127.0.0.1&apos;;const port = 3000;const server = http.createServer((req, res) =&gt; &#123;res.statusCode = 200;res.setHeader(&apos;Content-Type&apos;, &apos;text/plain&apos;);res.end(&apos;Hello World\\n&apos;);&#125;);server.listen(port, hostname, () =&gt; &#123;console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); 启动node程序，node app.js，在浏览器中输入： 1http://阿里云公网地址:端口号 发现压根没有用，当时就一句一句检查自己的代码，怕哪里写错了导致出不来结果。结果检查了一遍又一遍，完全没有发现错误，又重写了几遍，还是不行。于是在网上查了一番，最终找到了问题了。原来我的阿里云服务器是专有网络，而专用网络node部署在外部是不能直接访问的，要用nginx代理一下。 nginx的部署：安装nginx 安装方法有很多，我是用的yum安装的，这里有个安装教程传送门 12345// 添加CentOS 7 Nginx yum资源库rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm// 安装yum install -y nginx 检查nginx是否安装成功 1234nginx -t // 有下面提示代表安装成功nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful 启动nginx 1234systemctl start nginx.service // 启动nginxsystemctl stop nginx.service // 停止nginxsystemctl restart nginx.service // 重启nginxsystemctl enable nginx.service // 设置开机启动 nginx启动后在浏览器中输入http:// 阿里云外网地址，你就可以看到一个nginx页面 nginx配置：nginx配置文件为 /etc/nginx/nginx.conf 123456server &#123; listen 80; location / &#123; proxy_pass http://127.0.0.1:3000; # 本地node启动的端口为3000 &#125;&#125; 将proxy_pass 的值改为 http://127.0.0.1:3000, 3000的端口号为本地node启动的端口号。 重启nginx 1systemctl restart nginx.service 在浏览器中输入http://阿里云外网地址，这时就可以看到hello word。nginx的功能非常强大，这里只用了反向代理。关于nginx更多的介绍，这里有篇文章写得非常好传送门 node 程序运行中不能碰到错误，否则就会挂掉。所以forever诞生了，forever可以守卫node进程，node挂了后会自动重启。 安装forever模块，守护node进程。 1234npm install forever -g // 全局安装forever start app.js // 启动node服务forever stop app.js // 停止node服务forever start -w app.js // 监听当前文件，当有文件变动时自动重启node应用。 到此node部署就完成了。","tags":[{"name":"阿里云","slug":"阿里云","permalink":"http://yoursite.com/tags/阿里云/"},{"name":"centos","slug":"centos","permalink":"http://yoursite.com/tags/centos/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"hexo+github搭建个人博客主题篇","date":"2017-08-03T17:40:04.000Z","path":"2017/08/04/hexo-github搭建个人博客主题篇/","text":"上期我们讲了hexo搭建博客的基础篇，将一个博客从无到有搭建出来并部署到github上。但是hexo有个重点部分没有讲到，那就是主题。hexo允许你定制自己的主题，这就是为什么hexo可以做出丰富的界面效果。因为主题是十分重要的一部分，所以单独拿来讲讲。 hexo的主题放在themes文件夹下，一个主题就是一个文件夹，hexo的默认主题是landscape。这里有一些好的主题推荐，传送门都是github上比较火的，第一个都到8000多star了。 修改主题： 修改_config.yml文件 里的主题配置，找到文件里的theme字段，将landscape改为你要使用的主题。 主题相关配置主要是修改主题文件下的_config.yml文件配置，配置详情请查阅相关主题文档。好看实用的主题有很多，每个人的爱好也不同，可以去看看各种主题，选择自己喜欢的主题。今天我要讲的是一个我非常喜欢的主题hexo-theme-yilia。该主题简洁漂亮，并且提供了我非常喜欢的相册模块。github地址,作者的文档写的很详细，我这里就不啰嗦了。 注意：在主题theme同目录的_config.yml文件中要加入如下字段： 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true // 放在配置文件的最下方。 如果配置中有什么问题可以看作者博客的备份文件传送门,虽然下载的主题文件没有相册模块，但是作者提供的备份文件中有相册模块。于是拿来分析一波，发现改一下配置，我也能使用相册功能。 1、修改source/photos文件夹下index.ejs 作者相册里有两块，一块是Ins，一块是摄影。摄影是个独立的项目，我这里只是把Ins这块留下了。 删除这段代码 1234&lt;div class=&quot;photos-btn-wrap&quot;&gt; &lt;a class=&quot;photos-btn active&quot; href=&quot;javascript:void(0)&quot;&gt;Ins&lt;/a&gt; &lt;a class=&quot;photos-btn&quot; target=&quot;_blank&quot; href=&quot;http://litten.me/gallery/&quot;&gt;摄影&lt;/a&gt;&lt;/div&gt; 12&lt;a href=&quot;https://www.instagram.com/litten225/&quot; target=&quot;_blank&quot; class=&quot;open-ins&quot;&gt;图片来自instagram，正在加载中…&lt;/a&gt; // 去掉href 、target属性，将提示文字改为你自己提示如：图片加载中。。。。 2、接下来修改source/photos文件夹下ins.js 当时查看作者ins模块下的图片，发现这个模块的文件都来自http://litten.me这个域名下。于是在photos文件夹下文件中搜索这个域名，就在ins.js中大约119行找到了域名。看了一下正好是作者的图片配置信息。作者图片都放在http://litten.me/域名对应服务器的ins-min和ins文件夹下。ins-min是小图，ins对于的是大图。 如果我们把图片的链接地址换成我们的链接地址，不久可以使用相册模块了。我们虽然没有服务器，但是图片也可以放在github上啊。于是我在github建了个picture的项目，在项目下建了个picture文件夹，传了几张图片上去了。打开图片后，只是在页面中看到图片，并不是图片的连接，右键在新标签中代开图片，这时就能获取到图片的链接地址了。 如：https://raw.githubusercontent.com/keenjaan/pictrue/master/picture/1.jpg keenjaan改为你的github名称 第一个picture改为你的仓库名称 第二个picture改为你的文件夹名称。 1.jpg几位图片名称 修改这段代码 123456var minSrc = &apos;http://litten.me/ins-min/&apos; + data.link[i] + &apos;.min.jpg&apos;; var src = &apos;http://litten.me/ins/&apos; + data.link[i]; 修改为：var minSrc = &apos;https://raw.githubusercontent.com/github名称/仓库名称/master/文件夹名称/&apos; + data.link[i] + &apos;.jpg&apos;; var src = &apos;https://raw.githubusercontent.com/github名称/仓库名称/master/文件夹名称/&apos; + data.link[i]; 作者这里用了大图和小图，你也可以学作者一样建两个文件夹，分别放不同尺寸图片。我这里只使用一种图片。 3、最后修改source/photos文件夹下ins.json 1234567891011&quot;list&quot;: [&#123; &quot;date&quot;: &quot;2017-07&quot;, &quot;arr&quot;: &#123; &quot;year&quot;: 2017, &quot;month&quot;: 7, &quot;src&quot;: [&quot;&quot;, &quot;&quot;], &quot;link&quot;: [&quot;1&quot;, &quot;2&quot;], &quot;text&quot;: [&quot;picture1&quot;, &quot;picture2&quot;], &quot;type&quot;: [&quot;image&quot;, &quot;image&quot;] &#125; &#125;] 数据是按时间分的，按月份来划分。12345678910111213date 代表时间year 年份month 月份src 可以填空&quot;&quot;link代表图片的名字text 图片底下的文字type 文件格式，image和video代表图片和视频。 如果是视频的话，要在图片文件夹里放一个视频文件和一个同名的jpg缩略图。如果分大小图的话，缩略图放小图文件夹，视频放大图文件夹。 到此一个相册功能就改好了，你现在也拥有自己的相册了，快去试试吧。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]},{"title":"阿里云centos下部署mongodb","date":"2017-08-03T17:38:46.000Z","path":"2017/08/04/阿里云centos下部署mongodb/","text":"本教程是在阿里云cenots下部署mongodb的过程，整个过程遇到不少坑，浪费了很多时间。在网上查了很多教程，但是由于教程大多太久了，环境都不一样了，所以教程绝大部分走不通。为此走过不少坑，所以在此做一下记录。 环境：系统：阿里云centos 7.3 64位 mongodb版本： 3.4 因为使用yum安装非常方便，所以下文使用yum安装，。 修改yum包管理配置： 1vi /etc/yum.repos.d/mongodb-org-3.4.repo // 会自动新建mongodb-org-3.4.repo文件 复制下面配置信息： 12345[mongodb-org-3.4]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/gpgcheck=0enabled=1 tips: 不懂linux去恶补下基础知识（vi 编辑器） 安装mongodb 1yum install -y mongodb-org // 一路yes安装mongodb 启动mongodb 1systemctl start mongod.service // 启动mongodb 停止mongodb 1systemctl stop mongod.service // 停止mongodb 重启mongodb 1systemctl restart mongod.service // 重启mongodb 设置mongodb开机启动 1systemctl enable mongod.service // 设置开机启动 tips： centos 7将service命令 改为systemctl。 mongodb安装成功，默认配置文件路径为：/etc/mongod.conf。执行cat /etc/mongod.conf,查看文件的配置。 配置文件是yaml 语法： 1234systemLog: destination: file logAppend: true path: /var/log/mongodb/mongod.log // 日志文件储存路径 1234storage: dbPath: /var/lib/mongo // 数据储存路径 journal: enabled: true 你也可以更改储存路径，更改路径时因先新建相关文件夹和文件，这里不做修改。 本地连接mongodb： 1234mongo // 连接本地mongodbshow dbs // 查看所有数据库use mydb // 切换mydb数据库，没有会自动添加show collections // 查看集合 默认情况下，mongodb是没有安全验证的，都可以连接到该数据库。因为mongodb要求是部署在一个安全的环境中，而不需要验证。 远程连接： 在本地window中，打开cmd，执行mongo 192.168.31.54 (192.168.31.54为你的阿里云服务器外网地址)，发现连接不上，网上找了很长时间，终于解决了。 1、在阿里云esc实例中设置安全组，把27017端口开放，mongodb 默认端口为27017，阿里云为了安全端口默认都是关闭的。 2、修改mongodb配置文件： 1vi /etc/mongod.conf // 编辑配置文件 123net: port: 27017 bindIp: 127.0.0.1 // mongodb 默认绑定的IP地址 默认情况下，阿里云只绑定了127.0.0.1本地地址，只能本地访问，需要在上面加上阿里云内网地址。 1bindIp: 127.0.0.1,阿里云内网地址 重启mongodb服务器： 1systemctl restart mongod.service 在本地cmd中再执行 1mongo 阿里云外网地址 // 发现现在可以连接上了。 到此本地和远程都可以连接上mongodb了，远程可以用可视化工具Robomongo连接，直接输入阿里云外网地址和端口号27017即可以远程连接成功。虽然远程可以连接上mongodb，但是只要知道阿里云外网地址，谁都可以通过远程连接到数据库，并且修改数据库了的数据，这样是非常不安全的。所以实际部署中是不建议bindIp里面加上阿里云内网地址的，只能通过本地访问。远程连接只是为了能方便用可视化工具Robomongo方便管理数据库。如果要想用Robomongo，又想数据库不能随便被别人连接上可以吗？当然可以，只需开启身份认证。 默认情况下mongodb是关闭身份认证的，开启身份认证需如下步骤： 1、修改mongodb配置文件 1234vi /etc/mongod.conf // 编辑mongod.conf文件security: // 去掉security前面# authorization: enabled // 添加这句开启认证 在网上看了很多教程关于开启身份认证的，使用auth=true发现不行，后来才知道是教程太老了，配置字段都变了,坑的我找了很长时间。 2、添加超级管理员 默认Mongodb是没有管理员等用户信息的，开启身份认证是需要添加用户信息验证。首先添加的应该是admin数据库里的管理员账号，他用于其他数据库的用户添加、修改、删除等一些权限控制。 执行如下操作： 123456789mongo // 本地连接数据库use admin // 切换到admin数据库，没有会自动添加db.createUser( // 创建管理员用户 &#123; user: &quot;admin&quot;, // 账号 pwd: &quot;admin&quot;, // 密码 roles: [ &#123; role: &quot;root&quot;, db: &quot;admin&quot; &#125; ] // 角色：超级管理员，数据库：admin &#125;) 创建成功后会输出Successfully added user。。。 重启mongodb 1systemctl restart mongod.service 执行 12345mongo // 连接数据库show dbs // 显示所有数据库，这步会报错，说没有通过验证。use admin // 切换到admin数据库db.auth(&apos;admin&apos;,&apos;admin&apos;) // 用上面设置的账号密码登录如果返回 &apos;1&apos;表示验证成功， 如果是 &apos;0&apos; 表示验证失败 身份验证开启了，在window端cmd中执行下面命令 1234mongo 阿里云外网地址 // 发现连接失败，因为没有通过验证。如果执行下面这句mongo 阿里云外网地址 -u &quot;admin&quot; -p &quot;admin&quot; --authenticationDatabase admin // 发现连接成功 Robomongo身份认证连接： 切换到Authorization选项，选中Perform authorization,填上Database, user name, password,就可以连接成功了。 mongodb不像mysql，验证的用户对所有数据库都有读写的能力，不同的库需要配置相关的用户信息才能对该库进行读写。比如有个myblog的数据库，需要对其有读写的能力，新建一个具有读写能力的用户。 命令如下： 123456789101112mongo // 连接数据库use admin // 切换到admin数据库db.auth(&apos;admin&apos;,&apos;admin&apos;) // auth验证登录use myblog // 切换到myblog数据库db.createUser( // 创建普通用户 &#123; user: &quot;keen&quot;, // 账号 pwd: &quot;123&quot;, // 密码 roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;myblog&quot; &#125; ] // 角色：读写，数据库：myblog &#125;)db.auth(&apos;keen&apos;, &apos;123&apos;) // 使用新建用户keen验证登录 到此整个mongodb配置结束了,关于mongodb的身份认证，以及权限控制，可以看看这篇文章，写的很详细。[传送门](http://shift-alt-ctrl.iteye.com/blog/2262709)","tags":[{"name":"阿里云","slug":"阿里云","permalink":"http://yoursite.com/tags/阿里云/"},{"name":"centos","slug":"centos","permalink":"http://yoursite.com/tags/centos/"},{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]},{"title":"阿里云centos下部署ftp","date":"2017-08-03T17:30:31.000Z","path":"2017/08/04/阿里云centos下部署ftp/","text":"环境：1、Centos 7.3 2、阿里云专有网络 安装123yum install -y vsftpd // 安装systemctl start vsftpd.service // 启动vsftpd服务 ftp权限配置：vsftpd 的配置目录为 /etc/vsftpd，包含下列的配置文件： 1、vsftpd.conf // 主配置文件 2、ftpusers // 禁止访问 FTP 服务器的用户列表 3、user_list // 用户访问控制 这里只做简单配置，禁止切换目录。编辑 /etc/vsftpd/vsftpd.conf，找到下面两处配置并修改： 123anonymous_enable=NO (改为NO) // 禁用匿名用户 chroot_local_user=YES (改为YES) // 禁止切换根目录 切换目录权限配置：chroot_list_enable=YES/NO（NO） 设置是否启用chroot_list_file配置项指定的用户列表文件。默认值为NO。 chroot_list_file=/etc/vsftpd/chroot_list 用于指定用户列表文件，该文件用于控制哪些用户可以切换到用户家目录的上级目录。 chroot_local_user=YES/NO（NO） 用于指定用户列表文件中的用户是否允许切换到上级目录。默认值为NO。 12345678910111213通过搭配能实现以下几种效果：1、当chroot_list_enable=YES，chroot_local_user=YES时，在/etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。2、当chroot_list_enable=YES，chroot_local_user=NO时，在/etc/vsftpd.chroot_list文件中列出的用户，不能切换到其他目录；未在文件中列出的用户，可以切换到其他目录。3、当chroot_list_enable=NO，chroot_local_user=YES时，所有的用户均不能切换到其他目录。4、当chroot_list_enable=NO，chroot_local_user=NO时，所有的用户均可以切换到其他目录。 故上面配置属于第三种情况，所有用户不能切换到其他目录。 如果使用情况1或者情况2时，要在/etc/vsftpd下新建chroot_list文件，配置相关用户。 重启服务： 1systemctl restart vsftpd.service 12345创建一个用户 ftpuseruseradd ftpuser限制用户 ftpuser只能通过 FTP 访问服务器，而不能直接登录服务器：usermod -s /sbin/nologin ftpuser 上面两步可以合二为一：1useradd ftpuser -s /sbin/nologin 为用户 ftpuser 设置密码 123456方法一：echo &quot;keenjaan&quot; | passwd ftpuser --stdin方法二：passwd ftpuser输入两遍密码即可 2.5 为用户分配主目录在/var中创建相关的目录 1mkdir -p /var/ftp/pub 配置主目录即目录权限配置： 123/var/ftp // 为主目录, 该目录只能读，不能写和执行/var/ftp/pub // 文件具有读、写、执行权限 设置访问权限 12345chmod a-w /var/ftp &amp;&amp; chmod 777 -R /var/ftp/pub对ftp文件：有读取权限，没有写入权限。对pub文件及其所有子文件：最高权限，读写，执行。 关于chmod命令：参考这个连接传送门12345678910111213141516171819202122232425262728293031chmod [-cfvR] [--help] [--version] mode file...参数 : mode : 权限设定字串，格式如下 : [ugoa...][[+-=][rwxX]...][,...]，其中u 表示该文件的拥有者[user]，g 表示与该文件的拥有者属于组(group)，o 表示其他用户[other]，a 表示这三者皆是[all]。（常用）+ 表示增加权限、（常用）- 表示取消权限、（常用）= 表示唯一设定权限。r 表示有可读取的权限，w 表示有可写入的权限，x 表示有可执行的权限，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。-c : 若该文件权限确实已经更改，才显示其更改动作-f : 若该文件权限无法被更改也不要显示错误讯息-v : 显示权限变更的详细资料-R : 对目前目录下的所有文件与子目录进行相同的权限变更 （常用）--help : 显示帮助--version : 显示版本r=4，w=2，x=1rwx属性则4+2+1=7；rw-属性则4+2=6；r-x属性则4+1=5。 设置为用户的主目录： 1usermod -d /var/ftp ftpuser 在阿里云安全组中开放21端口号。 使用FileZilla登录到ftp报错，553，最终设置FileZilla传输设置里传输模式为主动，就能正常传输了。 到此ftp配置完成。这里有篇关于ftp配置文章很详细，传送门","tags":[{"name":"阿里云","slug":"阿里云","permalink":"http://yoursite.com/tags/阿里云/"},{"name":"centos","slug":"centos","permalink":"http://yoursite.com/tags/centos/"},{"name":"ftp","slug":"ftp","permalink":"http://yoursite.com/tags/ftp/"}]},{"title":"hexo+github搭建个人博客基础篇","date":"2017-08-02T12:50:31.000Z","path":"2017/08/02/hexo+github搭建个人博客基础篇/","text":"最近想用GitHub搭建个人博客，于是下功夫搜索了一番。网上有很多的教程，最终决定用hexo来搭建，因为简单、快速。本教程只是对整个搭建的记录，以及遇到的一些坑，高手可以直接跳过。 说明：本教程针对window环境 首先hexo是一款基于Node.js的静态博客框架, 官网传送门，所以你要了解一些node基础；其次是结合github自然要有一个github账号；最后hexo生成的代码上传需要用到git。 准备工作1、安装node 2、安装git 3、申请github账号 上面步骤都很简单，不具体说明了，不懂得赶紧去恶补。 安装hexonpm install hexo-cli -g 进入放博客的文件夹，执行下面命令： hexo init blog // 该命令会创建一个blog的文件夹，里面就是相关配置文件。 cd blog // 进入blog文件夹 npm install // 安装package.json里配置的模块 hexo server // 运行本地服务，在网页中查看效果。 安装完后进入文件夹，可以看到如下文件夹及文件： node_modules // npm 的安装模块文件 scaffolds // 布局文件 source // 资源文件，文章都放在该文件下的_posts themes // 主题文件 .gitignore // git上传忽略文件配置 _config.yml // 核心配置文件 package.json // 描述npm安装包的文件 新建文章： hexo new [layout] title layout 即scaffolds 中的文件 hexo new ‘post’ // 新建文章，如果没有指定布局，默认新建的是post布局， 新文章在source 下的_posts下 hexo new page ‘node’ // 在文件夹source下，的page下新建一个名为node的文章，如果没有page文件夹会自动新建一个。 当然也可以手动添加文件和文件夹。 github上传配置当在本地写好文章后就要传到github上，下面做相关配置。 打开_config.yml文件，在最小面找到deploy字段，做如下配置： deploy: type: git repo: git@github.com:youname/youname.github.io.git（将youname换成你的GitHub名字） branch: master 然后执行npm install hexo-deployer-git –save， 安装相关模块，不然上传代码时会报错。 配置Github 创建一个与你用户名相同的仓库，如： youname.github.io，youname 换成你的github用户名 在本地git中生成钥密，ssh-keygen -t rsa -C”youremail@example.com” 邮箱换成自己邮箱，然后一路回车，使用默认值即可。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件。打开id_rsa.pub，复制里面的所有内容，然后登陆GitHub，打开个人的settings，选中SSH and GPG keys 选项，然后，点NEW SSH Key，填上任意Title，在文本框里粘贴id_rsa.pub文件的内容。 关于git的用法以及github相关配置不懂得可以移步廖雪峰老师的站点学习[传送门](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000) 生成文件上传github hexo generate // 生成静态页面文件夹public hexo server // 开启本地服务查看效果（默认端口4000） hexo deploy // 将.deploy目录部署到GitHub hexo clean // 删除public文件夹 每次上传文件前要先删除public文件夹，在生成静态页面，最后上传github，故执行如下命令： hexo clean hexo generate hexo deploy 打开你的github，查看youname.github.io文件上传成功没，如果成功了在网址中打开youname.github.io，查看博客。 注：在window环境下，执行hexo deploy命令一定要在git bash里运行，不能在cmd中运行，不然报错，当时为了这个问题坑了一把。 小技巧： 每次重新上传都要执行者三个命令会很麻烦，可以偷个懒，打开package.json文件，在里面加入scripts字段： “scripts”: { ​ “dev”: “hexo clean &amp;&amp; hexo g &amp;&amp; hexo d” } 然后在git bash 里执行npm run dev即可一步执行这些操作。 域名配置到此博客基本搭建完成，如果你想要你的博客有个独特的域名，其实配置非常简单。 1、购买域名 2、配置解析 以万网申请的域名为例，如图： 3、在在public文件夹下新建名为CNAME的文件， 在里面填写你的域名，执行hexo d上传代码，输入域名查看效果。 tips：每次执行hexo clean 后public文件都被删除了，CNAME文件也被删除了，这样每次都要重新创建这个文件会很麻烦。其实解决办法很简单，把配置文件CNAME放在source文件下，重新生成后，你发现在public文件中就有CNAME这个文件了。 结语到此博客就搭建完成了，但是对于hexo还有一块很重要的没有讲，那就是主题。hexo的强大体现在它丰富的主题。下期就讲一下我非常喜欢的一款简洁、漂亮的主题yilia。主题篇已完成[传送门]","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]}]